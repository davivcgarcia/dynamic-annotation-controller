<!DOCTYPE html>
<html>

<head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>scheduler: Go Coverage Report</title>
        <style>
                body {
                        background: black;
                        color: rgb(80, 80, 80);
                }

                body,
                pre,
                #legend span {
                        font-family: Menlo, monospace;
                        font-weight: bold;
                }

                #topbar {
                        background: black;
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        height: 42px;
                        border-bottom: 1px solid rgb(80, 80, 80);
                }

                #content {
                        margin-top: 50px;
                }

                #nav,
                #legend {
                        float: left;
                        margin-left: 10px;
                }

                #legend {
                        margin-top: 12px;
                }

                #nav {
                        margin-top: 10px;
                }

                #legend span {
                        margin: 0 5px;
                }

                .cov0 {
                        color: rgb(192, 0, 0)
                }

                .cov1 {
                        color: rgb(128, 128, 128)
                }

                .cov2 {
                        color: rgb(116, 140, 131)
                }

                .cov3 {
                        color: rgb(104, 152, 134)
                }

                .cov4 {
                        color: rgb(92, 164, 137)
                }

                .cov5 {
                        color: rgb(80, 176, 140)
                }

                .cov6 {
                        color: rgb(68, 188, 143)
                }

                .cov7 {
                        color: rgb(56, 200, 146)
                }

                .cov8 {
                        color: rgb(44, 212, 149)
                }

                .cov9 {
                        color: rgb(32, 224, 152)
                }

                .cov10 {
                        color: rgb(20, 236, 155)
                }
        </style>
</head>

<body>
        <div id="topbar">
                <div id="nav">
                        <select id="files">

                                <option value="file0">
                                        github.com/davivcgarcia/dynamic-annotation-controller/internal/scheduler/parser.go
                                        (90.4%)</option>

                                <option value="file1">
                                        github.com/davivcgarcia/dynamic-annotation-controller/internal/scheduler/scheduler.go
                                        (92.0%)</option>

                        </select>
                </div>
                <div id="legend">
                        <span>not tracked</span>

                        <span class="cov0">not covered</span>
                        <span class="cov8">covered</span>

                </div>
        </div>
        <div id="content">

                <pre class="file" id="file0" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scheduler

import (
        "fmt"
        "time"

        "github.com/robfig/cron/v3"

        schedulerv1 "github.com/davivcgarcia/dynamic-annotation-controller/api/v1"
)

// ScheduleParser handles parsing and validation of schedule configurations
type ScheduleParser struct {
        cronParser cron.Parser
}

// NewScheduleParser creates a new schedule parser with standard cron options
func NewScheduleParser() *ScheduleParser <span class="cov8" title="1">{
        return &amp;ScheduleParser{
                cronParser: cron.NewParser(cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow),
        }
}</span>

// ValidateSchedule validates a schedule configuration and returns any validation errors
func (p *ScheduleParser) ValidateSchedule(schedule schedulerv1.ScheduleConfig) error <span class="cov8" title="1">{
        switch schedule.Type </span>{
        case "datetime":<span class="cov8" title="1">
                return p.validateDateTimeSchedule(schedule)</span>
        case "cron":<span class="cov8" title="1">
                return p.validateCronSchedule(schedule)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid schedule type: %s, must be 'datetime' or 'cron'", schedule.Type)</span>
        }
}

// ValidateScheduleForCreation validates a schedule configuration for new rule creation
func (p *ScheduleParser) ValidateScheduleForCreation(schedule schedulerv1.ScheduleConfig) error <span class="cov8" title="1">{
        switch schedule.Type </span>{
        case "datetime":<span class="cov8" title="1">
                return p.validateDateTimeScheduleForCreation(schedule)</span>
        case "cron":<span class="cov0" title="0">
                return p.validateCronSchedule(schedule)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid schedule type: %s, must be 'datetime' or 'cron'", schedule.Type)</span>
        }
}

// validateDateTimeSchedule validates datetime-based schedule configuration (allows past times for existing schedules)
func (p *ScheduleParser) validateDateTimeSchedule(schedule schedulerv1.ScheduleConfig) error <span class="cov8" title="1">{
        if schedule.StartTime == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("startTime is required for datetime schedule type")
        }</span>

        <span class="cov8" title="1">startTime := schedule.StartTime.Time

        // If endTime is specified, validate it's after startTime
        if schedule.EndTime != nil </span><span class="cov8" title="1">{
                endTime := schedule.EndTime.Time
                if !endTime.After(startTime) </span><span class="cov8" title="1">{
                        return fmt.Errorf("endTime (%v) must be after startTime (%v)", endTime, startTime)
                }</span>
        }

        // Validate that cron-specific fields are not set
        <span class="cov8" title="1">if schedule.CronExpression != "" </span><span class="cov8" title="1">{
                return fmt.Errorf("cronExpression should not be set for datetime schedule type")
        }</span>
        <span class="cov8" title="1">if schedule.Action != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("action should not be set for datetime schedule type")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateDateTimeScheduleForCreation validates datetime-based schedule configuration for new rules
func (p *ScheduleParser) validateDateTimeScheduleForCreation(schedule schedulerv1.ScheduleConfig) error <span class="cov8" title="1">{
        if err := p.validateDateTimeSchedule(schedule); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">now := time.Now()
        startTime := schedule.StartTime.Time

        // Validate that start time is not in the past (with 1 minute tolerance) for new rules
        if startTime.Before(now.Add(-time.Minute)) </span><span class="cov8" title="1">{
                return fmt.Errorf("startTime cannot be in the past: %v", startTime)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateCronSchedule validates cron-based schedule configuration
func (p *ScheduleParser) validateCronSchedule(schedule schedulerv1.ScheduleConfig) error <span class="cov8" title="1">{
        if schedule.CronExpression == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("cronExpression is required for cron schedule type")
        }</span>

        <span class="cov8" title="1">if schedule.Action == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("action is required for cron schedule type")
        }</span>

        <span class="cov8" title="1">if schedule.Action != "apply" &amp;&amp; schedule.Action != "remove" </span><span class="cov8" title="1">{
                return fmt.Errorf("action must be 'apply' or 'remove', got: %s", schedule.Action)
        }</span>

        // Validate cron expression syntax
        <span class="cov8" title="1">_, err := p.cronParser.Parse(schedule.CronExpression)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid cron expression '%s': %w", schedule.CronExpression, err)
        }</span>

        // Validate that datetime-specific fields are not set
        <span class="cov8" title="1">if schedule.StartTime != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("startTime should not be set for cron schedule type")
        }</span>
        <span class="cov8" title="1">if schedule.EndTime != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("endTime should not be set for cron schedule type")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CalculateNextExecution calculates the next execution time for a given schedule
func (p *ScheduleParser) CalculateNextExecution(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time) (*time.Time, error) <span class="cov8" title="1">{
        if err := p.ValidateSchedule(schedule); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid schedule: %w", err)
        }</span>

        <span class="cov8" title="1">switch schedule.Type </span>{
        case "datetime":<span class="cov8" title="1">
                return p.calculateDateTimeNextExecution(schedule, lastExecution)</span>
        case "cron":<span class="cov8" title="1">
                return p.calculateCronNextExecution(schedule, lastExecution)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported schedule type: %s", schedule.Type)</span>
        }
}

// calculateDateTimeNextExecution calculates next execution for datetime schedules
func (p *ScheduleParser) calculateDateTimeNextExecution(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time) (*time.Time, error) <span class="cov8" title="1">{
        now := time.Now()
        startTime := schedule.StartTime.Time

        // If we haven't executed the start action yet and start time is in the future
        if lastExecution == nil &amp;&amp; startTime.After(now) </span><span class="cov8" title="1">{
                return &amp;startTime, nil
        }</span>

        // If we have an end time and haven't executed the end action yet
        <span class="cov8" title="1">if schedule.EndTime != nil </span><span class="cov8" title="1">{
                endTime := schedule.EndTime.Time

                // If we've executed the start but not the end, and end time is in the future
                if lastExecution != nil &amp;&amp; lastExecution.Equal(startTime) &amp;&amp; endTime.After(now) </span><span class="cov8" title="1">{
                        return &amp;endTime, nil
                }</span>
        }

        // No more executions needed
        <span class="cov8" title="1">return nil, nil</span>
}

// calculateCronNextExecution calculates next execution for cron schedules
func (p *ScheduleParser) calculateCronNextExecution(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time) (*time.Time, error) <span class="cov8" title="1">{
        cronSchedule, err := p.cronParser.Parse(schedule.CronExpression)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse cron expression: %w", err)
        }</span>

        <span class="cov8" title="1">var baseTime time.Time
        if lastExecution != nil </span><span class="cov8" title="1">{
                baseTime = *lastExecution
        }</span> else<span class="cov8" title="1"> {
                baseTime = time.Now()
        }</span>

        <span class="cov8" title="1">nextTime := cronSchedule.Next(baseTime)
        return &amp;nextTime, nil</span>
}

// GetSchedulePhase determines the current phase of a schedule based on current time and execution history
func (p *ScheduleParser) GetSchedulePhase(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time) (string, error) <span class="cov8" title="1">{
        if err := p.ValidateSchedule(schedule); err != nil </span><span class="cov8" title="1">{
                return "failed", err
        }</span>

        <span class="cov8" title="1">now := time.Now()

        switch schedule.Type </span>{
        case "datetime":<span class="cov8" title="1">
                return p.getDateTimePhase(schedule, lastExecution, now), nil</span>
        case "cron":<span class="cov8" title="1">
                return p.getCronPhase(schedule, lastExecution, now), nil</span>
        default:<span class="cov0" title="0">
                return "failed", fmt.Errorf("unsupported schedule type: %s", schedule.Type)</span>
        }
}

// getDateTimePhase determines phase for datetime schedules
func (p *ScheduleParser) getDateTimePhase(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time, now time.Time) string <span class="cov8" title="1">{
        startTime := schedule.StartTime.Time

        // If start time is in the future
        if startTime.After(now) </span><span class="cov8" title="1">{
                return "pending"
        }</span>

        // If we have an end time
        <span class="cov8" title="1">if schedule.EndTime != nil </span><span class="cov8" title="1">{
                endTime := schedule.EndTime.Time

                // If end time has passed
                if endTime.Before(now) </span><span class="cov8" title="1">{
                        return "completed"
                }</span>

                // If we're between start and end time
                <span class="cov8" title="1">if startTime.Before(now) &amp;&amp; endTime.After(now) </span><span class="cov8" title="1">{
                        return "active"
                }</span>
        } else<span class="cov8" title="1"> {
                // No end time, so if start time has passed, we're completed
                if startTime.Before(now) </span><span class="cov8" title="1">{
                        return "completed"
                }</span>
        }

        <span class="cov0" title="0">return "active"</span>
}

// getCronPhase determines phase for cron schedules
func (p *ScheduleParser) getCronPhase(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time, now time.Time) string <span class="cov8" title="1">{
        // Cron schedules are always active (recurring)
        return "active"
}</span>

// IsTimeToExecute checks if it's time to execute a schedule
func (p *ScheduleParser) IsTimeToExecute(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time) (bool, error) <span class="cov8" title="1">{
        nextExecution, err := p.CalculateNextExecution(schedule, lastExecution)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if nextExecution == nil </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">now := time.Now()
        // Allow 1 minute tolerance for execution timing
        return nextExecution.Before(now.Add(time.Minute)), nil</span>
}

// GetExecutionAction determines what action should be taken for the current execution
func (p *ScheduleParser) GetExecutionAction(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time) (string, error) <span class="cov8" title="1">{
        switch schedule.Type </span>{
        case "datetime":<span class="cov8" title="1">
                return p.getDateTimeAction(schedule, lastExecution)</span>
        case "cron":<span class="cov8" title="1">
                return schedule.Action, nil</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("unsupported schedule type: %s", schedule.Type)</span>
        }
}

// getDateTimeAction determines the action for datetime schedules
func (p *ScheduleParser) getDateTimeAction(schedule schedulerv1.ScheduleConfig, lastExecution *time.Time) (string, error) <span class="cov8" title="1">{
        startTime := schedule.StartTime.Time

        // If we haven't executed yet, the next action is apply (regardless of timing)
        if lastExecution == nil </span><span class="cov8" title="1">{
                return "apply", nil
        }</span>

        // If we have an end time and haven't executed the end action yet
        <span class="cov8" title="1">if schedule.EndTime != nil </span><span class="cov8" title="1">{
                // If we've executed the start but not the end
                if lastExecution.Equal(startTime) </span><span class="cov8" title="1">{
                        return "remove", nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no action needed at this time")</span>
}
</pre>

                <pre class="file" id="file1" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scheduler

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/go-logr/logr"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"

        schedulerv1 "github.com/davivcgarcia/dynamic-annotation-controller/api/v1"
)

// ScheduleAction represents the type of action to perform
type ScheduleAction string

const (
        ActionApply  ScheduleAction = "apply"
        ActionRemove ScheduleAction = "remove"
)

// ScheduledTask represents a task to be executed at a specific time
type ScheduledTask struct {
        RuleID          string
        RuleName        string
        RuleNamespace   string
        Action          ScheduleAction
        ExecuteAt       time.Time
        Annotations     map[string]string
        Selector        metav1.LabelSelector
        TargetResources []string
}

// TaskExecutor defines the interface for executing annotation operations
type TaskExecutor interface {
        ExecuteTask(ctx context.Context, task ScheduledTask) error
}

// TimeScheduler defines the interface for managing scheduled annotation operations
type TimeScheduler interface {
        // ScheduleRule adds or updates a rule in the scheduler
        ScheduleRule(rule *schedulerv1.AnnotationScheduleRule) error
        
        // UnscheduleRule removes a rule from the scheduler
        UnscheduleRule(ruleID string) error
        
        // Start begins the scheduler's operation
        Start(ctx context.Context) error
        
        // Stop gracefully shuts down the scheduler
        Stop() error
        
        // GetNextExecutionTime returns the next execution time for a rule
        GetNextExecutionTime(ruleID string) (*time.Time, error)
        
        // GetScheduledTaskCount returns the number of scheduled tasks
        GetScheduledTaskCount() int
}

// timeScheduler implements the TimeScheduler interface
type timeScheduler struct {
        parser   *ScheduleParser
        executor TaskExecutor
        logger   logr.Logger

        // Task management
        tasks     map[string]*ScheduledTask // ruleID -&gt; task
        taskQueue chan *ScheduledTask
        
        // Synchronization
        mu       sync.RWMutex
        stopCh   chan struct{}
        doneCh   chan struct{}
        started  bool
        
        // Configuration
        tickInterval    time.Duration
        maxConcurrency  int
        workerSemaphore chan struct{}
}

// NewTimeScheduler creates a new time-based scheduler
func NewTimeScheduler(executor TaskExecutor, logger logr.Logger) TimeScheduler <span class="cov8" title="1">{
        return &amp;timeScheduler{
                parser:          NewScheduleParser(),
                executor:        executor,
                logger:          logger,
                tasks:           make(map[string]*ScheduledTask),
                taskQueue:       make(chan *ScheduledTask, 1000), // Buffer for 1000 tasks
                stopCh:          make(chan struct{}),
                doneCh:          make(chan struct{}),
                tickInterval:    30 * time.Second, // Check every 30 seconds
                maxConcurrency:  10,               // Max 10 concurrent executions
                workerSemaphore: make(chan struct{}, 10),
        }
}</span>

// ScheduleRule adds or updates a rule in the scheduler
func (s *timeScheduler) ScheduleRule(rule *schedulerv1.AnnotationScheduleRule) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        ruleID := s.getRuleID(rule)
        
        // Validate the schedule
        if err := s.parser.ValidateSchedule(rule.Spec.Schedule); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid schedule for rule %s: %w", ruleID, err)
        }</span>

        // Calculate next execution time
        <span class="cov8" title="1">var lastExecution *time.Time
        if rule.Status.LastExecutionTime != nil </span><span class="cov8" title="1">{
                lastExecution = &amp;rule.Status.LastExecutionTime.Time
        }</span>

        <span class="cov8" title="1">nextExecution, err := s.parser.CalculateNextExecution(rule.Spec.Schedule, lastExecution)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate next execution for rule %s: %w", ruleID, err)
        }</span>

        // If no next execution, remove the rule
        <span class="cov8" title="1">if nextExecution == nil </span><span class="cov8" title="1">{
                delete(s.tasks, ruleID)
                s.logger.Info("Rule completed, removed from scheduler", "ruleID", ruleID)
                return nil
        }</span>

        // Determine the action to take
        <span class="cov8" title="1">action, err := s.parser.GetExecutionAction(rule.Spec.Schedule, lastExecution)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to determine action for rule %s: %w", ruleID, err)
        }</span>

        // Create or update the scheduled task
        <span class="cov8" title="1">task := &amp;ScheduledTask{
                RuleID:          ruleID,
                RuleName:        rule.Name,
                RuleNamespace:   rule.Namespace,
                Action:          ScheduleAction(action),
                ExecuteAt:       *nextExecution,
                Annotations:     rule.Spec.Annotations,
                Selector:        rule.Spec.Selector,
                TargetResources: rule.Spec.TargetResources,
        }

        s.tasks[ruleID] = task
        s.logger.Info("Rule scheduled", 
                "ruleID", ruleID, 
                "action", action, 
                "executeAt", nextExecution.Format(time.RFC3339))

        return nil</span>
}

// UnscheduleRule removes a rule from the scheduler
func (s *timeScheduler) UnscheduleRule(ruleID string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        delete(s.tasks, ruleID)
        s.logger.Info("Rule unscheduled", "ruleID", ruleID)
        return nil
}</span>

// Start begins the scheduler's operation
func (s *timeScheduler) Start(ctx context.Context) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.started </span><span class="cov8" title="1">{
                return fmt.Errorf("scheduler is already started")
        }</span>

        <span class="cov8" title="1">s.started = true
        s.logger.Info("Starting time scheduler")

        // Start the main scheduler loop
        go s.schedulerLoop(ctx)
        
        // Start worker goroutines for task execution
        for i := 0; i &lt; s.maxConcurrency; i++ </span><span class="cov8" title="1">{
                go s.taskWorker(ctx, i)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Stop gracefully shuts down the scheduler
func (s *timeScheduler) Stop() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !s.started </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">s.logger.Info("Stopping time scheduler")
        close(s.stopCh)
        
        // Wait for scheduler to stop
        &lt;-s.doneCh
        
        s.started = false
        s.logger.Info("Time scheduler stopped")
        return nil</span>
}

// GetNextExecutionTime returns the next execution time for a rule
func (s *timeScheduler) GetNextExecutionTime(ruleID string) (*time.Time, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        task, exists := s.tasks[ruleID]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("rule %s not found in scheduler", ruleID)
        }</span>

        <span class="cov8" title="1">return &amp;task.ExecuteAt, nil</span>
}

// GetScheduledTaskCount returns the number of scheduled tasks
func (s *timeScheduler) GetScheduledTaskCount() int <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        return len(s.tasks)
}</span>

// schedulerLoop is the main loop that checks for tasks to execute
func (s *timeScheduler) schedulerLoop(ctx context.Context) <span class="cov8" title="1">{
        defer close(s.doneCh)

        ticker := time.NewTicker(s.tickInterval)
        defer ticker.Stop()

        s.logger.Info("Scheduler loop started", "tickInterval", s.tickInterval)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Info("Scheduler loop stopping due to context cancellation")
                        return</span>
                case &lt;-s.stopCh:<span class="cov8" title="1">
                        s.logger.Info("Scheduler loop stopping due to stop signal")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        s.checkAndQueueTasks()</span>
                }
        }
}

// checkAndQueueTasks checks for tasks that are ready to execute and queues them
func (s *timeScheduler) checkAndQueueTasks() <span class="cov8" title="1">{
        s.mu.RLock()
        now := time.Now()
        tasksToExecute := make([]*ScheduledTask, 0)

        for _, task := range s.tasks </span><span class="cov8" title="1">{
                // Check if task is ready to execute (with 1 minute tolerance)
                if task.ExecuteAt.Before(now.Add(time.Minute)) </span><span class="cov8" title="1">{
                        tasksToExecute = append(tasksToExecute, task)
                }</span>
        }
        <span class="cov8" title="1">s.mu.RUnlock()

        // Queue tasks for execution
        for _, task := range tasksToExecute </span><span class="cov8" title="1">{
                select </span>{
                case s.taskQueue &lt;- task:<span class="cov8" title="1">
                        s.logger.Info("Task queued for execution", 
                                "ruleID", task.RuleID, 
                                "action", task.Action,
                                "scheduledTime", task.ExecuteAt.Format(time.RFC3339))</span>
                default:<span class="cov0" title="0">
                        s.logger.Error(nil, "Task queue is full, dropping task", 
                                "ruleID", task.RuleID, 
                                "action", task.Action)</span>
                }
        }
}

// taskWorker processes tasks from the queue
func (s *timeScheduler) taskWorker(ctx context.Context, workerID int) <span class="cov8" title="1">{
        s.logger.Info("Task worker started", "workerID", workerID)
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        s.logger.Info("Task worker stopping due to context cancellation", "workerID", workerID)
                        return</span>
                case &lt;-s.stopCh:<span class="cov8" title="1">
                        s.logger.Info("Task worker stopping due to stop signal", "workerID", workerID)
                        return</span>
                case task := &lt;-s.taskQueue:<span class="cov8" title="1">
                        s.executeTaskWithSemaphore(ctx, task, workerID)</span>
                }
        }
}

// executeTaskWithSemaphore executes a task with concurrency control
func (s *timeScheduler) executeTaskWithSemaphore(ctx context.Context, task *ScheduledTask, workerID int) <span class="cov8" title="1">{
        // Acquire semaphore
        select </span>{
        case s.workerSemaphore &lt;- struct{}{}:<span class="cov8" title="1">
                defer func() </span><span class="cov8" title="1">{ &lt;-s.workerSemaphore }</span>()
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        case &lt;-s.stopCh:<span class="cov0" title="0">
                return</span>
        }

        <span class="cov8" title="1">s.logger.Info("Executing task", 
                "workerID", workerID,
                "ruleID", task.RuleID, 
                "action", task.Action,
                "scheduledTime", task.ExecuteAt.Format(time.RFC3339))

        // Execute the task
        if err := s.executor.ExecuteTask(ctx, *task); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err, "Failed to execute task", 
                        "workerID", workerID,
                        "ruleID", task.RuleID, 
                        "action", task.Action)
        }</span> else<span class="cov8" title="1"> {
                s.logger.Info("Task executed successfully", 
                        "workerID", workerID,
                        "ruleID", task.RuleID, 
                        "action", task.Action)
        }</span>

        // Remove the executed task from the scheduler
        // Note: The controller will reschedule the rule if needed
        <span class="cov8" title="1">s.mu.Lock()
        delete(s.tasks, task.RuleID)
        s.mu.Unlock()</span>
}

// getRuleID generates a unique identifier for a rule
func (s *timeScheduler) getRuleID(rule *schedulerv1.AnnotationScheduleRule) string <span class="cov8" title="1">{
        return types.NamespacedName{
                Namespace: rule.Namespace,
                Name:      rule.Name,
        }.String()
}</pre>

        </div>
</body>
<script>
        (function () {
                var files = document.getElementById('files');
                var visible;
                files.addEventListener('change', onChange, false);
                function select(part) {
                        if (visible)
                                visible.style.display = 'none';
                        visible = document.getElementById(part);
                        if (!visible)
                                return;
                        files.value = part;
                        visible.style.display = 'block';
                        location.hash = part;
                }
                function onChange() {
                        select(files.value);
                        window.scrollTo(0, 0);
                }
                if (location.hash != "") {
                        select(location.hash.substr(1));
                }
                if (!visible) {
                        select("file0");
                }
        })();
</script>

</html>